## 线上问题排查

### 生产环境
排查问题时需要保留现场，分布式微服务可留下一个现场，切断客户端链接。

### 示例
#### 服务假死、CPU过高
##### 问题描述
这种情况比较常见，100%是程序问题，特征是进程存在，CPU、内存数值正常，程序不再处理客户端任何请求或者不再执行任何任务。
##### 排查方案
```
#从服务器数据看问题
netstat -ant|awk '/^tcp/ {++S[$NF]} END {for(a in S) print (a,S[a])}'
如果TIME_WAIT过大，考虑程序中是否有tcp的交互，此处容易出现客户端未发送关闭请求的问题。
#查出直接可看出异常数值的pid
top 或者 ps aux |grep java
#查询指定进程的线程状态
#RUNNABLE,在虚拟机内执行的。运行中状态，可能里面还能看到locked字样，表明它获得了某把锁。
#BLOCKED,受阻塞并等待监视器锁。被某个锁(synchronizers)給block住了。
#WATING,无限期等待另一个线程执行特定操作。等待某个condition或monitor发生，一般停留在park(), wait(), sleep(),join() 等语句里。
#TIMED_WATING,有时限的等待另一个线程的特定操作。和WAITING的区别是wait()等语句加上了时间限制 wait(timeout)。
#TERMINATED,已退出的
如果是BLOCKED，检查该段代码附近是否有加锁，高并发消息消费时，不适用加锁，会造成锁等待。
```

##### 调优的针对性解决方案
###### 1 代码synchronized问题导致的
```
如果代码块所处理的数据确实需要保证原子性，可考虑使用redis存储，去掉synchronized，这会快很多。如果不能，再考虑优化优化代码/算法。
```
###### 2 数据库大量锁超时、死锁
```
锁超时：
考虑代码中的加锁对象是否为表级锁，在业务场景中，如果并发高且同时操作的数据位于同一行的频率不算高，则可以考虑用行级锁。否则用行级锁是巨大的灾难。
若并发度很高，对同一行数据更新很频繁，考虑调整业务。


死锁：
对加锁数据体现为行级锁，且对同一行并发度极高，通常体现在对同一行数据并发更新，容易造成死锁，如果数据并发不算特别高，且数据能接受更新延迟，考虑用行级锁。
大量死锁出现时，程序容易出现假死。

场景=
撮合引擎的结算端负责消费撮合引擎推送的撮合数据，涉及到更新订单表、更新账户表、新增各类记录数据等，消费端作为数据落地，需要满足原子、一致且稳定的更新多个表数据。由于撮合是基于内存的撮合，速度非常快，消费端需要承接大量高并发的操作。
典型的是更新账户表，对账户表的加锁是加行锁还是表锁合适呢？
推荐加表锁，同时调整业务。
金融交易领域，会出现机器人或第三方通过API参与交易，同一个账户每秒并发度非常高，行锁极容易死锁，大量死锁程序会直接挂掉，结算无效。表锁由于mysql内部优化执行顺序，对于多次操作的速度比行锁更快、效率更高。

优化建议：对特定账户（内部热账户）采取批量结算的模式，而非及时结算。给普通数据更好的运行环境。

通常来说，死锁都是应用设计的问题，通过调整业务流程、数据库对象设计、事务大小、以及访问数据库的SQL语句，绝大部分都可以避免。下面就通过实例来介绍几种避免死锁的常用方法。
    （１）在应用中，如果不同的程序会并发存取多个表，应尽量约定以相同的顺序为访问表，这样可以大大降低产生死锁的机会。如果两个session访问两个表的顺序不同，发生死锁的机会就非常高！但如果以相同的顺序来访问，死锁就可能避免。
    （２）在程序以批量方式处理数据的时候，如果事先对数据排序，保证每个线程按固定的顺序来处理记录，也可以大大降低死锁的可能。
    （３）在事务中，如果要更新记录，应该直接申请足够级别的锁，即排他锁，而不应该先申请共享锁，更新时再申请排他锁。
    （４）在REPEATEABLE-READ隔离级别下，如果两个线程同时对相同条件记录用SELECT...ROR UPDATE加排他锁，在没有符合该记录情况下，两个线程都会加锁成功。程序发现记录尚不存在，就试图插入一条新记录，如果两个线程都这么做，就会出现死锁。这种情况下，将隔离级别改成READ COMMITTED，就可以避免问题。
    （５）当隔离级别为READ COMMITED时，如果两个线程都先执行SELECT...FOR UPDATE，判断是否存在符合条件的记录，如果没有，就插入记录。此时，只有一个线程能插入成功，另一个线程会出现锁等待，当第１个线程提交后，第２个线程会因主键重出错，但虽然这个线程出错了，却会获得一个排他锁！这时如果有第３个线程又来申请排他锁，也会出现死锁。对于这种情况，可以直接做插入操作，然后再捕获主键重异常，或者在遇到主键重错误时，总是执行ROLLBACK释放获得的排他锁。
```
